= Auth Modules =

* [#introduction Introduction]
* [#available Available Modules]
* [#custom Custom Modules]

----

[=#introduction]
== Introduction ==

SQL Relay provides three built-in auth mechanisms, configurable by the //authtier// attribute of the instance tag.

* authtier="connection" - Users are authenticated/authorized against a static list.
* authtier="database" - Users are authenticated/authorized against the database itself.  Users must log into SQL Relay using a user/password combination that would be valid to log into the database directly.
* authtier="proxied" - Users are authenticated/authorized against the database itself using n-tier/proxy authentication.  SQL Relay is logged into the database as a user with permissions to proxy other users.  Users must log into SQL Relay using a user/password combination that the proxy user is configured to proxy.  This is currently only supported with Oracle databases.

{{{#!blockquote
( '''NOTE:''' Prior to version 0.65.0, authtier="database" defaulted to the behavior of authtier="proxied" fell back to the current behavior if the proxied behavior was unsupported.  There was no way to force authtier="database" behavior.  As of 0.65.0 the funcationality is split into two separate options.)
}}}

Auth modules allow the SQL Relay server programs to authenticate/authorize users in a manner other than the provided by the built-in mechanisms.

The //auths// section of the sqlrelay.conf file indicates which auth modules to load and what parameters to use when executing them.

{{{#!blockquote
@sqlrelay-auths-userlist.conf.html@
}}}

In this example, the //module// attribute specifies which module to load and the //user// tags specify the list of valid users and passwords.

Module configurations may have attributes and/or nested tags.  How these elements are interpreted is module-specific.

Auth modules can be "stacked".  Multiple modules may be loaded and multiple instances of the same type of module, with different configurations, may also be loaded.

{{{#!blockquote
@sqlrelay-auths-stacked.conf.html@
}}}

At startup, the SQL Relay server creates instances of the specified auth modules and initializes them.  When a client connects, the server passes the supplied credentials to each module, in the order that they were specified in the config file.  If a module successfully authenticates/authorizes a user, then the client is allowed to continue its session.  If a module fails to authenticate/authorize a user, then the credentials are passed on to the next module.  If all modules fail to authenticate/authorize a user, then the client is not allowed to continue its session.

[=#available]
== Available Modules ==

Currently, the following auth modules are available:

* '''userlist'''
* '''database'''
* '''proxied'''
* '''sqlrelay'''

=== userlist ===

The userlist module authenticates/authorizes a user against a static list of valid user/password combinations.  In fact, it has the same behavior as the default behavior of SQL Relay.  The only difference is that the syntax in the config file is a little different.

When using the userlist auth module, rather than using the //users// tag to specify valid users...

{{{#!blockquote
@sqlrelay-auths-users.conf.html@
}}}

...you would list the users inside of the tag for the module:

{{{#!blockquote
@sqlrelay-auths-userlist.conf.html@
}}}

[pwdencs.html Password encryption] modules may also be used.

{{{#!blockquote
@sqlrelay-auths-userlist-pwdenc.conf.html@
}}}

The userlist module can also authorize Kerberos-authenticated or Active Directory-authenticated users, as well as users authenticated by a TLS/SSL certificate.  The module automatically detects which athentication method to use, based on the credentials supplied by the client.

When configuring the module to authenticate a Kerberos/Active-Directory user, include the list of valid principals, and omit the password from each entry.

{{{#!blockquote
@sqlrelay-auths-krb_userlist.conf.html@
}}}

See the [../admin/configguide.html#krb SQL Relay Configuration Guide] for more information about configuring Kerberos and Active Directory encryption and authentication.

When configuring the module to authenticate a TLS/SSL user, include the list of valid client names, and omit the password from each entry.

{{{#!blockquote
@sqlrelay-auths-tls_userlist.conf.html@
}}}

If the client's certificate contains Subject Alternative Names then each SAN will be compared to each entry in the list.  If a match is found then the client is authorized.

If the client's certificate does not contain Subject Alternative Names, then the Common Name is compared to each entry in the list.  If a match is found then the client is authorized.

Note that this module only works if:

* TLS/SSL is enabled on the server-side.
* TLS Validation is enabled on the server-side.
* The client sends a certificate.

See the [../admin/configguide.html#tls SQL Relay Configuration Guide] for more information about configuring TLS/SSL encryption and authentication.

(Note, in previous versions of SQL Relay, there were separate krb_userlist and tls_userlist modules.  As of version 0.66.0, these have been merged with the userlist module.)

Since the userlist auth module appears to provide the exact same functionality as the built-in //users// tag, why would you want to use it instead of just using the built-in //users// tag?

The //users// tag is evaluated prior to evaluating any modules.  So, you must use the userlist module if you are stacking auth modules, and want to use a different auth module first, falling back to a static list of users if it fails.

=== database ===

The database module authenticates/authorizes a user against the database itself.  SQL Relay does this by checking the provided credentials against the credentials that are currently in use.  If they differ, then it logs out of the database and logs back in using the provided credentials.

{{{#!blockquote
'''NOTE:''' Database auth should not be used in an instance where dbase="router".  It's OK for the instances that the router routes to to use it but the router instance itself should not.  If database auth is used for that instance, then auth will fail.
}}}

{{{#!blockquote
'''NOTE:''' Prior to version 0.65.0, the "database" auth module defaulted to the behavior of the "proxied" auth module and fell back to this behavior if the proxied behavior was unsupported.  There was no way to force this behavior.  As of 0.65.0 the funcationality is split into two separate modules.
}}}

Using the database module has the same behavior as setting authtier="database" in the config file.  The only difference is that the syntax in the config file is different.

When using the database auth module, rather than using authtier="database"...

{{{#!blockquote
@sqlrelay-auths-authtier-database.conf.html@
}}}

...you would use the module instead:

{{{#!blockquote
@sqlrelay-auths-database.conf.html@
}}}

Since the userlist auth module appears to provide the exact same functionality as the built-in //authtier// attribute, why would you want to use it instead of just using the built-in //authtier// attribute?

There is no specific advantage to using the module instead of the attribute, other than consistency.  If you're using other auth modules in other instances, then you might also want to use the database auth module in this instance.

Note also, that the database auth module should not be used in a stacked configuration.  Or, at least, using it in a stacked configuration could lead to unexpected results.  When using database auth, each connection is left logged in as the most recently authenticated/authorized user.  If an SQL Relay user is authenticated/authorized by some other method, then there is no guarantee what user it will access the database as.

=== proxied ===

The proxied module authenticates/authorizes a user against the database itself.  SQL Relay logs into the database as a user with permissions to proxy other users.  For each client session, SQL Relay checks the provided credentials against the credentials that are currently in use.  If they differ, then it asks the proxy user to switch the user it's proxying to the provided user.

This is currently only supported with Oracle 8i or higher and requires database configuration.  See [oraclentier.html this document] for more information including instructions for configuring Oracle.

{{{#!blockquote
'''NOTE:''' Proxied auth should not be used in an instance where dbase="router".  It's OK for the instances that the router routes to to use it but the router instance itself should not.  If proxied auth is used for that instance, then auth will fail.
}}}

{{{#!blockquote
'''NOTE:''' Prior to version 0.65.0, the "database" auth module defaulted to the behavior of the "proxied" auth module and fell back to the current behavior if the proxied behavior was unsupported.  There was no way to force the database auth module's behavior.  As of 0.65.0 the funcationality is split into two separate modules.
}}}

Using the proxied module has the same behavior as setting authtier="proxied" in the config file.  The only difference is that the syntax in the config file is different.

When using the proxied auth module, rather than using authtier="proxied"...

{{{#!blockquote
@sqlrelay-auths-authtier-proxied.conf.html@
}}}

...you would use the module instead:

{{{#!blockquote
@sqlrelay-auths-proxied.conf.html@
}}}

Since the userlist auth module appears to provide the exact same functionality as the built-in //authtier// attribute, why would you want to use it instead of just using the built-in //authtier// attribute?

There is no specific advantage to using the module instead of the attribute, other than consistency.  If you're using other auth modules in other instances, then you might also want to use the proxied auth module in this instance.

Note also, that the proxied auth module should not be used in a stacked configuration.  Or, at least, using it in a stacked configuration could lead to unexpected results.  When using proxied auth, each connection is left logged in as the most recently authenticated/authorized user.  If an SQL Relay user is authenticated/authorized by some other method, then there is no guarantee what user it will access the database as.

=== sqlrelay ===

The sqlrelay module authenticates/authorizes a user against a table in a database, using another instance of SQL Relay to access that database.

The module's '''host''', '''port''', '''socket''', '''user''' and '''password''' paramters define which instance of SQL Relay to talk to.  The '''table''', '''usercolumn''' and '''passwordcolumn''' parameters define which table and which columns within the table to authenticate/authorize against.  If passwords aren't stored in plain text, then an optional '''passwordfunction''' parameter may specify the stored procedure used to encrypt the password.

{{{#!blockquote
@sqlrelay-auths-sqlrelay.conf.html@
}}}

[=#custom]
== Custom Modules ==

You can create your own custom auth modules too.

SQL Relay provides a base class for auth modules, called sqlrauth, defined in the header file: sqlrserver.h

It also provides a base class for credentials and a child class for user-password credentials.

{{{#!blockquote
@sqlrauth.h.html@
}}}

On non-Windows platforms, it's most likely installed in /usr/local/firstworks/include/sqlrelay if you built from source or /usr/include/sqlrelay if you installed a package.  On Windows platforms, it's most likely installed in C:\Program Files\Firstworks\include\sqlrelay.

The default implementaion of the constructor just sets the member variables //parameters//, //sqlrpe//, and //debug// to the corresponding passed-in values.  //parameters// is a representation of the XML tag in the sqlrelay.conf file that loaded the module.

By default, the destructor does nothing.

auth() does nothing by default and returns NULL, indicating that authentication/authorization failed.

A custom module module must contain a class that inherits from sqlrauth, implements the necessary methods, and implements a function to return an instance of the class.

Lets say we want to create a custom auth module that authenticates/authorizes a user against a hardcoded list of users.

We can create the file hardcoded.cpp:

{{{#!blockquote
@sqlrauth-hardcoded.cpp.html@
}}}

Here, the hardcoded class inherits from sqlrauth.  The constructor just calls the parent constructor.  The auth() method verifies that an appropriate type of credentials has been passed in, casts the credentials to a set of user-password credentials, compares the user and password to a hardcoded list, and returns the user if it matches or NULL if it doesn't.  It may seem odd to return the user rather than true/false, but some authentication methods pass a set of credentials (such as TLS's Common Name and Subject Alternative Names), and the auth() method must return specific credential was authorized.

Note the "new_sqlrauth_hardcoded()" function which just allocates an instance of hardcoded and returns it.  This function is essential to provide, and it is essential that it be named "new_sqlrauth_modulename" and take xmldomnode *, sqlrpwdencs *, and bool parameters.  It is also essential that it be wrapped with an //extern "C"// clause to prevent it from being name-mangled by the compiler.

To build the module on a Linux or Unix system, run a command like:

{{{#!blockquote
{{{
gcc -shared `sqlrserver-config --cflags` `rudiments-config --cflags` -o sqlrauth_hardcoded.so hardcoded.cpp `sqlrserver-config --libs` `rudiments-config --libs`
}}}
}}}

This will create the file sqlrauth_hardcoded.so

On Mac OSX, run a command like:

{{{#!blockquote
{{{
gcc -bundle `sqlrserver-config --cflags` `rudiments-config --cflags` -o sqlrauth_hardcoded.bundle hardcoded.cpp `sqlrserver-config --libs` `rudiments-config --libs`
}}}
}}}

This will create the sqlrauth_hardcoded.bundle

On Windows, run commands like:

{{{#!blockquote
{{{
cl /I"C:\Program Files\Firstworks\include" /c hardcoded.cpp
link -out:sqlrauth_hardcoded.dll /LIBPATH:"C:\Program Files\Firstworks\lib" libsqlrserver.lib librudiments.lib
}}}
}}}

This will create the sqlrauth_hardcoded.dll

It is essential that the file be named: sqlrauth_modulename.extension

To install the new module, copy it to the SQL Relay "modules" directory.  On non-Windows platforms, that is most likely /usr/local/firstworks/libexec/sqlrelay if you built from source, or /usr/libexec/sqlrelay if you installed a package.  On Windows platforms, that is most likely C:\Program Files\Firstworks\libexec\sqlrelay

To configure an instance of SQL Relay to use your module, you will need to update the sqlrelay.conf file to include a "auths" section:

{{{#!blockquote
@sqlrelay-auths-hardcoded.conf.html@
}}}

The server will see the module="hardcoded" attribute in the sqlrelay.conf file, look in the "modules" directory for sqlrauth_hardcoded.//extension//, load it and and run the new_sqlrauth_hardcoded() method to get an instance of the hardcoded class and then run the various methods of that class.

This example module doesn't have any parameters, but if you create a module that does then you can access them via the the protected "parameters" member variable.  For example:

{{{#!blockquote
@sqlrauth-param.cpp.html@
}}}

Refer to the Rudiments documentation for more info on the [http://rudiments.sourceforge.net/rudiments/classes/html/classxmldomnode.html xmldomnode class].

<html>
<head>
<title>SQL Relay - Extension Modules - Auth</title>
<link href="../css/styles.css" rel="stylesheet">
</head>
<body>

<span class="heading1">Auth Modules</span><br><br>

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#available">Available Modules</a></li>
<li><a href="#custom">Custom Modules</a></li>
</ul>

<hr>

<br><a name="introduction"></a>
<span class="heading2">Introduction</span><br>

<p>SQL Relay provides two built-in auth mechanisms, configurable by the <i>authtier</i> attribute of the instance tag.  If authtier="connection" then users are authenticated/authorized against a static list.  If authtier="database" then users are authenticated/authorized against the database itself and users must log into SQL Relay using a user/password combination that would be valid to log into the database directly.</p>

<p>Auth modules allow the SQL Relay server programs to authenticate/authorize users in some other manner.<p>

<p>The <i>auths</i> section of the sqlrelay.conf file indicates which auth modules to load and what parameters to use when executing them.</p>

<blockquote>
@sqlrelay-auths-userlist.conf.html@
</blockquote>

<p>In this example, the <i>module</i> attribute specifies which module to load and the <i>user</i> tags specify the list of valid users and passwords.</p>

<p>Module configurations may have attributes and/or nested tags.  How these elements are interpreted is module-specific.</p>

<p>Auth modules can be "stacked".  Multiple modules may be loaded and multiple instances of the same type of module, with different configurations, may also be loaded.</p>

<blockquote>
@sqlrelay-auths-stacked.conf.html@
</blockquote>

<p>At startup, the SQL Relay server creates instances of the specified auth modules and initializes them.  When a client connects, the server passes the supplied credentials to each module, in the order that they were specified in the config file.  If a module successfully authenticates/authorizes a user, then the client is allowed to continue its session.  If a module fails to authenticate/authorize a user, then the credentials are passed on to the next module.  If all modules fail to authenticate/authorize a user, then the client is not allowed to continue its session.</p>

<br><a name="available"></a>
<span class="heading2">Available Modules</span><br>

<p>Currently, the following auth modules are available:</p>

<b>
<ul>
<li>userlist</li>
<li>database</li>
<li>sqlrelay</li>
<li>krb_userlist</li>
<li>tls_userlist</li>
</ul>
</b>

<br><br>
<span class="heading3">userlist</span><br>

<p>The userlist module authenticates/authorizes a user against a static list of valid user/password combinations.  In fact, it has the same behavior as the default behavior of SQL Relay.  The only difference is that the syntax in the config file is a little different.</p>

<p>When using the userlist auth module, rather than using the <i>users</i> tag to specify valid users...</p>

<blockquote>
@sqlrelay-auths-users.conf.html@
</blockquote>

<p>...you would list the users inside of the tag for the module:</p>

<blockquote>
@sqlrelay-auths-userlist.conf.html@
</blockquote>

<p><a href="pwdencs.html">Password encryption</a> modules may also be used.</p>

<blockquote>
@sqlrelay-auths-userlist-pwdenc.conf.html@
</blockquote>

<p>Since the userlist auth module appears to provide the exact same functionality as the built-in <i>users</i> tag, why would you want to use it instead of just using the built-in <i>users</i> tag?</p>

<p>The <i>users</i> tag is evaluated prior to evaluating any modules.  So, you must use the userlist module if you are stacking auth modules, and want to use a different auth module first, falling back to a static list of users if it fails.</p>

<br><br>
<span class="heading3">database</span><br>

<p>The database module authenticates/authorizes a user against the database itself.  This causes SQL Relay to switch which user it is logged into the database as.</p>

<p>When using SQL Relay with Oracle 8i or higher, it switches users without logging out.  The database connection must be configured to log into the database as a user that can proxy other users and the client must attempt to log in to SQL Relay as one of the users that can be proxied.  See <a href="oraclentier.html">this document</a> for more information including instructions for configuring Oracle.</p>

<p>When SQL Relay is used with any other database, it simply logs out and logs back in as a different user.  This is somewhat ineffecient and defeats the value of keeping persistent database connections but might be useful for particular applications.</p>

<p><b>NOTE:</b> Database auth should not be used in an instance where dbase="router".  It's OK for the instances that the router uses to use it but not the router instance itself.  If database auth is used for that instance, then auth will fail.</p>

<p>Using the database module has the same behavior as setting authtier="database" in the config file.  The only difference is that the syntax in the config file is different.</p>

<p>When using the database auth module, rather than using authtier="database"...</p>

<blockquote>
@sqlrelay-auths-authtier-database.conf.html@
</blockquote>

<p>...you would use the module instead:</p>

<blockquote>
@sqlrelay-auths-database.conf.html@
</blockquote>

<p>Since the userlist auth module appears to provide the exact same functionality as the built-in <i>authtier</i> attribute, why would you want to use it instead of just using the built-in <i>authtier</i> attribute?</p>

<p>There is no specific advantage to using the module instead of the attribute, other than consistency.  If you're using other auth modules in other instances, then you might also want to use the database auth module in this instance.</p>

<p>Note also, that the database auth module should not be used in a stacked configuration.  Or, at least, using it in a stacked configuration could lead to unexpected results.  When using database authentication/authorization, each connection is left logged in as the most recently authenticated/authorized user.  If an SQL Relay user is authenticated/authorized by some other method, then there is no guarantee what user it will access the database as.</p>

<br><br>
<span class="heading3">sqlrelay</span><br>

<p>The sqlrelay module authenticates/authorizes a user against a table in a database, using another instance of SQL Relay to access that database.</p>

<p>The module's <b>host</b>, <b>port</b>, <b>socket</b>, <b>user</b> and <b>password</b> paramters define which instance of SQL Relay to talk to.  The <b>table</b>, <b>usercolumn</b> and <b>passwordcolumn</b> parameters define which table and which columns within the table to authenticate/authorize against.  If passwords aren't stored in plain text, then an optional <b>passwordfunction</b> parameter may specify the stored procedure used to encrypt the password.</p>

<blockquote>
@sqlrelay-auths-sqlrelay.conf.html@
</blockquote>

<br><br>
<span class="heading3">krb_userlist</span><br>

<p>The krb_userlist module authorizes a Kerberos-authenticated or Active Directory-authenticated user against a static list of valid users.</p>

<blockquote>
@sqlrelay-auths-krb_userlist.conf.html@
</blockquote>

<p>See the <a href="../admin/configguide.html#krb">SQL Relay Configuration Guide</a> for more information about configuring Kerberos and Active Directory authentication and encryption.</p>

<br><br>
<span class="heading3">tls_userlist</span><br>

<p>The tls_userlist module authorizes the Subject Alternative Names or Common Name provided in the client-provided TLS/SSL certificate against a static list of valid names.</p>

<blockquote>
@sqlrelay-auths-tls_userlist.conf.html@
</blockquote>

<p>If the client's certificate contains Subject Alternative Names then each SAN is compared to each entry in the list.  If a match is found then the client is authorized.</p>

<p>If the client's certificate does not contain Subject Alternative Names, then the Common Name is compared to each entry in the list.  If a match is found then the client is authorized.</p>

<p>Note that this module only works if:</p>

<ul>
<li>TLS/SSL is enabled on the server-side.</li>
<li>TLS Validation is enabled on the server-side.</li>
<li>The client sends a certificate.</li>
</ul>

<p>See the <a href="../admin/configguide.html#tls">SQL Relay Configuration Guide</a> for more information about configuring TLS/SSL authentication and encryption.</p>

<br><a name="custom"></a>
<span class="heading2">Custom Modules</span><br>

<p>You can create your own custom auth modules too.</p>

<p>SQL Relay provides a base class for auth modules, called sqlrauth, defined in the header file: sqlrserver.h</p>

<blockquote>
@sqlrauth.h.html@
</blockquote>

<p>On non-Windows platforms, it's most likely installed in /usr/local/firstworks/include/sqlrelay if you built from source or /usr/include/sqlrelay if you installed a package.  On Windows platforms, it's most likely installed in C:\Program Files\Firstworks\include\sqlrelay.</p>

<p>The default implementaion of the constructor just sets the member variables <i>parameters</i> and <i>sqlrpe</i> to the corresponding passed-in values.  <i>parameters</i> is a representation of the XML tag in the sqlrelay.conf file that loaded the module.</p>

<p>By default, the destructor does nothing.</p>

<p>auth() does nothing by default and returns false, indicating that authentication/authorization failed.</p>

<p>A custom module module must contain a class that inherits from sqlrauth, implements the necessary methods, and implements a function to return an instance of the class.</p>

<p>Lets say we want to create a custom auth module that authenticates/authorizes a user against a hardcoded list of users.</p>

<p>We can create the file hardcoded.cpp:</p>

<blockquote>
@sqlrauth-hardcoded.cpp.html@
</blockquote>

<p>Here, the hardcoded class inherits from sqlrauth.  The constructor just calls the parent constructor.  The auth() method compares the user and password to a hardcoded list and returns true if it matches or false if it doesn't.</p>

<p>Note the "new_sqlrauth_hardcoded()" function which just allocates an instance of hardcoded and returns it.  This function is essential to provide, and it is essential that it be named "new_sqlrauth_<i>modulename</i>" and take xmldomnode * and sqlrpwdencs * parameters.  It is also essential that it be wrapped with an <i>extern "C"</i> clause to prevent it from being name-mangled by the compiler.</p>

<p>To build the module on a Linux or Unix system, run a command like:</p>

<blockquote><b>
gcc -shared `sqlrserver-config --cflags` `rudiments-config --cflags` -o sqlrauth_hardcoded.so hardcoded.cpp `sqlrserver-config --libs` `rudiments-config --libs`
</b></blockquote>

<p>This will create the file sqlrauth_hardcoded.so</p>

<p>On Mac OSX, run a command like:</p>

<blockquote><b>
gcc -bundle `sqlrserver-config --cflags` `rudiments-config --cflags` -o sqlrauth_hardcoded.bundle hardcoded.cpp `sqlrserver-config --libs` `rudiments-config --libs`
</b></blockquote>

<p>This will create the sqlrauth_hardcoded.bundle</p>

<p>On Windows, run commands like:</p>

<blockquote><b>
cl /I"C:\Program Files\Firstworks\include" /c hardcoded.cpp<br>
link -out:sqlrauth_hardcoded.dll /LIBPATH:"C:\Program Files\Firstworks\lib" libsqlrserver.lib librudiments.lib
</b></blockquote>

<p>This will create the sqlrauth_hardcoded.dll</p>

<p>It is essential that the file be named "sqlrauth_<i>modulename</i>.<i>extension</i>".</p>

<p>To install the new module, copy it to the SQL Relay "modules" directory.  On non-Windows platforms, that is most likely /usr/local/firstworks/libexec/sqlrelay if you built from source, or /usr/libexec/sqlrelay if you installed a package.  On Windows platforms, that is most likely C:\Program Files\Firstworks\libexec\sqlrelay</p>

<p>To configure an instance of SQL Relay to use your module, you will need to update the sqlrelay.conf file to include a "auths" section:</p>

<blockquote>
@sqlrelay-auths-hardcoded.conf.html@
</blockquote>

<p>The server will see the module="hardcoded" attribute in the sqlrelay.conf file, look in the "modules" directory for sqlrauth_hardcoded.<i>extension</i>, load it and and run the new_sqlrauth_hardcoded() method to get an instance of the hardcoded class and then run the various methods of that class.</p>

<p>This example module doesn't have any parameters, but if you create a module that does then you can access them via the the protected "parameters" member variable.  For example:</p>

<blockquote>
@sqlrauth-param.cpp.html@
</blockquote>

<p>Refer to the Rudiments documentation for more info on the <a href="http://rudiments.sourceforge.net/rudiments/classes/html/classxmldomnode.html">xmldomnode class</a>.</p>

</body>
</html>

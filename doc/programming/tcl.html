<html>
<head>
<title>firstworks   Programming with SQL Relay using the TCL API</title>
<link href="../css/styles.css" rel="stylesheet">
</head>
<body>

<span class="heading1">Programming with SQL Relay using the TCL API</span><br><br>

<ul>
<li><a href="#session">Establishing a Sessions</a></li>
<li><a href="#query">Executing Queries</a></li>
<li><a href="#commit">Commits and Rollbacks</a></li>
<li><a href="#temptables">Temporary Tables</a></li>
<li><a href="#errors">Catching Errors</a></li>
<li><a href="#bindvars">Substitution and Bind Variables</a></li>
<li><a href="#rebinding">Re-Binding and Re-Executing</a></li>
<li><a href="#fields">Accessing Fields in the Result Set</a></li>
<li><a href="#largeresultsets">Dealing With Large Result Sets</a></li>
<li><a href="#cursors">Cursors</a></li>
<li><a href="#columns">Getting Column Information</a></li>
<li><a href="#storedprocedures">Stored Procedures</a></li>
<li><a href="#caching">Caching The Result Set</a></li>
<li><a href="#suspending">Suspending and Resuming Sessions</a></li>
</ul>

<a name="session"></a>
<span class="heading2">Establishing a Session</span><br><br>

<p>To use SQL Relay, you have to identify the connection that you intend to 
use.</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

        ... execute some queries ...
</pre>
</blockquote>

<p>After calling the constructor, a session is established when the first 
query, ping() or identify() is run.</p>

<p>For the duration of the session, the client stays connected to a database
connection daemon.  While one client is connected, no other client can connect.
Care should be taken to minimize the length of a session.</p>

<p>If you're using a transactional database, ending a session has a catch.
Database connection daemons can be configured to send either a commit or
rollback at the end of a session if DML queries were executed during the
session with no commit or rollback.  Program accordingly.</p>

<a name="query"></a>
<span class="heading2">Executing Queries</span><br><br>

<p>Call sendQuery() or sendFileQuery() to run a query.</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

catch {<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;select * from my_table&quot;</font>}

        ... do some stuff that takes a short time ...

catch {<font color="#008b8b">$cur</font> sendFileQuery <font color="#ff00ff">&quot;/usr/local/myprogram/sql&quot;</font> <font color="#ff00ff">&quot;myquery.sql&quot;</font>}
<font color="#008b8b">$con</font> endSession

        ... do some stuff that takes a long time ...

catch {<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;select * from my_other_table&quot;</font>}
<font color="#008b8b">$con</font> endSession

        ... process the result <font color="#a52a2a"><b>set</b></font> ...
</pre>
</blockquote>

<p>Note the call to endSession() after the call to sendFileQuery().  Since the
program does some stuff that takes a long time between that query and the next,
ending the session there allows another client an opportunity to use that
database connection while your client is busy.  The next call to sendQuery() 
establishes another session.  Since the program does some stuff that takes a 
short time between the first two queries, it's OK to leave the session open 
between them.</p>

<a name="commit"></a>
<span class="heading2">Commits and Rollbacks</span><br><br>

<p>If you need to execute a commit or rollback, you should use the commit()
and rollback() methods of the SQLRelay::Connection class rather than 
sending a "commit" or "rollback" query.  There are two reasons for this.  
First, it's much more efficient to call the methods.  Second, if you're writing 
code that can run on transactional or non-transactional databases, some 
non-transactional databases will throw errors if they receive a "commit" or 
"rollback" query, but by calling the commit() and rollback() methods you 
instruct the database connection daemon to call the commit and rollback API 
methods for that database rather than issuing them as queries.  If the API's 
have no commit or rollback methods, the calls do nothing and the database 
throws no error.  This is especially important when using SQL Relay with 
ODBC.</p>

<p>You can also turn Autocommit on or off with the autoCommitOn() and
autoCommitOff() methods of the SQLRelay::Connection class.  When 
Autocommit is on, the database performs a commit after each successful DML or 
DDL query.  When Autocommit is off, the database commits when the client 
instructs it to, or (by default) when a client disconnects.  For databases that
don't support Autocommit, autoCommitOn() and autoCommitOff() have no effect.</p>

<a name="temptables"></a>
<span class="heading2">Temporary Tables</span><br><br>

<p>Some databases support temporary tables.  That is, tables which are
automatically dropped or truncated when an application closes it's connection
to the database or when a transaction is committed or rolled back.</p>

<p>For databases which drop or truncate tables when a transaction is committed
or rolled back, temporary tables work naturally.</p>

<p>However, for databases which drop or truncate tables when an application
closes it's connection to the database, there is an issue.  Since SQL Relay
maintains persistent database connections, when an application disconnects from
SQL Relay, the connection between SQL Relay and the database remains, so
the database does not know to drop or truncate the table.  To remedy this
situation, SQL Relay parses each query to see if it created a temporary table,
keeps a list of temporary tables and drops (or truncates them) when the
application disconnects from SQL Relay.  Since each database has slightly
different syntax for creating a temporary table, SQL Relay parses each query
according to the rules for that database.</p>

<p>In effect, temporary tables should work when an application connects to
SQL Relay in the same manner that they would work if the application connected
directly to the database.</p>

<a name="errors"></a>
<span class="heading2">Catching Errors</span><br><br>

<p>If your call to sendQuery() or sendFileQuery() returns a 0, the query failed.
You can find out why by catching the error and displaying it.</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

catch {<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;select * from my_table&quot;</font>} error

<font color="#a52a2a"><b>if</b></font> {<font color="#008b8b">$error</font> != <font color="#ff00ff">1</font>} {
        puts <font color="#008b8b">$error</font>
}
</pre>
</blockquote>

<a name="bindvars"></a>
<span class="heading2">Substitution and Bind Variables</span><br><br>

<p>Programs rarely execute fixed queries.  More often than not, some part
of the query is dynamically generated.  It's convenient to store queries in 
files so they can be changed by a non-TCL programmer.  The SQL Relay API 
provides methods for making substitutions and binds in those queries.</p>

<p>For a detailed discussion of substitutions and binds, see
<a href="binds.html">this document</a>.

<p>Rather than just calling sendFileQuery() you call prepareFileQuery(),
substitution(), inputBind() and executeQuery().</p>

<blockquote>
<PRE>
/usr/local/myprogram/sql/myquery.sql:

	select * from mytable $(whereclause)

Program code:<br>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cur</font> prepareFileQuery <font color="#ff00ff">&quot;/usr/local/myprogram/sql&quot;</font> <font color="#ff00ff">&quot;myquery.sql&quot;</font>
<font color="#008b8b">$cur</font> substitution <font color="#ff00ff">&quot;whereclause&quot;</font> <font color="#ff00ff">&quot;where col1=:value1&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;value1&quot;</font> <font color="#ff00ff">&quot;true&quot;</font>
<font color="#008b8b">$cur</font> executeQuery

        ... process the result <font color="#a52a2a"><b>set</b></font> ...
</pre>
</blockquote>

<p>If you're using a database with an embedded procedural language, you may
want to retrieve data from a call to one of it's functions.  To facilitate
this, SQL Relay provides the defineOutputBind() and getOutputBind() methods.</p>

<blockquote>
PL/SQL Procedure:<br>
<pre>
<font color="#6858c8">FUNCTION</font> sp_mytable <font color="#6858c8">RETURN</font> types.cursorType
l_cursor types.cursorType;
<font color="#6858c8">BEGIN</font>
        OPEN l_cursor <font color="#6858c8">FOR</font> <font color="#a02828"><b>SELECT</b></font> * <font color="#6858c8">FROM</font> mytable;
        <font color="#6858c8">RETURN</font> l_cursor;
<font color="#6858c8">END</font>;
</pre>
<br>
Program code:
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;begin  :result:=addTwoNumbers(:num1,:num2);  end;&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;num1&quot;</font> <font color="#ff00ff">10</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;num2&quot;</font> <font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;result&quot;</font> <font color="#ff00ff">100</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> <font color="#008b8b">$result</font> [<font color="#008b8b">$cur</font> getOutputBindAsInteger <font color="#ff00ff">&quot;result&quot;</font>]
<font color="#008b8b">$con</font> endSession

        ... do something with the result ...
</pre>
</blockquote>

<p>The getOutputBind() method returns a NULL value as an empty string.  
If you would it to come back as undefined instead, you can call the 
getNullsAsUndefined() method.  To revert to the default behavior, you can
call getNullsAsEmptyStrings().</p>

<p>The getOutputBind() method returns a string, if you would like to get the
value as a long or double, you can use getOutputBindAsLong() or
getOutputBindAsDouble().</p>

<p>If you are using Oracle 8i or higher, you can insert data into BLOB
and CLOB columns using the inputBindBlob(), inputBindClob() methods.</p>

<p>If you are curious how many bind variables have been declared in a query,
you can call countBindVariables() after preparing the query.</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cur</font> executeQuery <font color="#ff00ff">&quot;create table images (image blob, description clob)&quot;</font>

... read an <font color="#2e8b57"><b>image</b></font> <font color="#6a5acd">from</font> a file into imagedata and the <font color="#6a5acd">length</font> of the
        file into imagelength ...

... read a description from a file into description and the length of
        the file into desclength ...

<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;insert into images values (:image,:desc)&quot;</font>
<font color="#008b8b">$cur</font> inputBindBlob <font color="#ff00ff">&quot;image&quot;</font> <font color="#008b8b">$imagedata</font> <font color="#008b8b">$imagelength</font>
<font color="#008b8b">$cur</font> inputBindClob <font color="#ff00ff">&quot;desc&quot;</font> <font color="#008b8b">$description</font> <font color="#008b8b">$desclength</font>
<font color="#008b8b">$cur</font> executeQuery
</pre>
</blockquote>

<p>Likewise, with Oracle 8i, you can retreive BLOB or CLOB data using
defineOutputBindBlob(), defineOutputBindClob(), getOutputBind() and
getOutputBindLength().</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;begin  select image into :image from images;  select description into :desc from images;  end;&quot;</font>
<font color="#008b8b">$cur</font> defineOutputBindBlob <font color="#ff00ff">&quot;image&quot;</font>
<font color="#008b8b">$cur</font> defineOutputBindClob <font color="#ff00ff">&quot;desc&quot;</font>
<font color="#008b8b">$cur</font> executeQuery

<font color="#a52a2a"><b>set</b></font> img [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;image&quot;</font>]
<font color="#a52a2a"><b>set</b></font> imagelength [<font color="#008b8b">$cur</font> getOutputBindLength <font color="#ff00ff">&quot;image&quot;</font>]

<font color="#a52a2a"><b>set</b></font> desc [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;desc&quot;</font>]
<font color="#a52a2a"><b>set</b></font> desclength [<font color="#008b8b">$cur</font> getOutputBindLength <font color="#ff00ff">&quot;desc&quot;</font>]

<font color="#008b8b">$con</font> endSession

... do something with img and desc ...
</pre>
</blockquote>

<p>Sometimes it's convenient to bind a bunch of variables that may or may not 
actually be in the query.  For example, if you are building a web based
application, it may be easy to just bind all the form variables/values from the
previous page, even though some of them don't appear in the query.  Databases
usually generate errors in this case.  Calling validateBinds() just prior to
calling executeQuery() causes the API to check the query for each bind variable
before actually binding it, preventing those kinds of errors.  There is a 
performance cost associated with calling validateBinds().</p>


<a name="rebinding"></a>
<span class="heading2">Re-Binding and Re-Execution</span><br><br>

<p>Another feature of the prepare/bind/execute paradigm is the ability to 
prepare, bind and execute a query once, then re-bind and re-execute the query 
over and over without re-preparing it.  If your backend database natively 
supports this paradigm, you can reap a substantial performance improvement.</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;select * from mytable where mycolumn&gt;:value&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;value&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> executeQuery

... process the result <font color="#a52a2a"><b>set</b></font> ...

<font color="#008b8b">$cur</font> clearBinds
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;value&quot;</font> <font color="#ff00ff">5</font>
<font color="#008b8b">$cur</font> executeQuery

... process the result <font color="#a52a2a"><b>set</b></font> ...

<font color="#008b8b">$cur</font> clearBinds
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;value&quot;</font> <font color="#ff00ff">10</font>
<font color="#008b8b">$cur</font> executeQuery

... process the result <font color="#a52a2a"><b>set</b></font> ...
</pre>
</blockquote>

<a name="fields"></a>
<span class="heading2">Accessing Fields in the Result Set</span><br><br>

<p>The rowCount(), colCount() and getField() methods are useful for processing
result sets.</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;select * from my_table&quot;</font>
<font color="#008b8b">$con</font> endSession

<font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> row <font color="#ff00ff">0</font>} {<font color="#008b8b">$row</font>&lt;[<font color="#008b8b">$cur</font> rowCount]} {<font color="#a52a2a"><b>incr</b></font> row} {
        <font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> col <font color="#ff00ff">0</font>} {<font color="#008b8b">$col</font>&lt;[<font color="#008b8b">$cur</font> colCount]} {<font color="#a52a2a"><b>incr</b></font> col} {
                puts [<font color="#008b8b">$cur</font> getFieldByIndex <font color="#008b8b">$row</font> <font color="#008b8b">$col</font>]
        }
}
</pre>
</blockquote>

<p>The getField() method returns a string.  If you would like to get a field as
a long or double, you can use getFieldAsLong() and getFieldAsDouble().</p>

<p>You can also use getRow() to get the entire row.</p>


<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;select * from my_table&quot;</font>
<font color="#008b8b">$con</font> endSession

<font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> row <font color="#ff00ff">0</font>} {<font color="#008b8b">$row</font>&lt;[<font color="#008b8b">$cur</font> rowCount]} {<font color="#a52a2a"><b>incr</b></font> row} {
        <font color="#a52a2a"><b>set</b></font> rowarray [<font color="#008b8b">$cur</font> getRow <font color="#008b8b">$row</font>]
        <font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> col <font color="#ff00ff">0</font>} {<font color="#008b8b">$col</font>&lt;[<font color="#008b8b">$cur</font> colCount]} {<font color="#a52a2a"><b>incr</b></font> col} {
                puts [<font color="#a52a2a"><b>lindex</b></font> <font color="#008b8b">$rowarray</font> <font color="#008b8b">$col</font>]
        }
}
</pre>
</blockquote>

<p>If you want to access the result set, but don't care about the
column information (column names, types or sizes) and don't mind getting
fields by their numeric index instead of by name,  you can call the
dontGetColumnInfo() method prior to executing your query.  This can result
in a performance improvement, especially when many queries with small
result sets are executed in rapid succession.  You can call getColumnInfo()
again later to turn off this feature.</p>

<a name="largeresultsets"></a>
<span class="heading2">Dealing With Large Result Sets</span><br><br>

<p>SQL Relay normally buffers the entire result set.  This can speed things up 
at the cost of memory.  With large enough result sets, it makes sense to buffer the result set in chunks instead of all at once.</p>

<p>Use setResultSetBufferSize() to set the number of rows to buffer at a time.
Calls to getRow(), getRowHash() and getField() cause the chunk containing the 
requested field to be fetched.  Rows in that chunk are accessible but rows 
before it are not.</p>

<p>For example, if you setResultSetBufferSize(5) and execute a query that 
returns 20 rows, rows 0-4 are available at once, then rows 5-9, then 10-14, 
then 15-19.  When rows 5-9 are available, getField(0,0) will return NULL and 
getField(11,0) will cause rows 10-14 to be fetched and return the requested
value.</p>

<p>When buffering the result set in chunks, don't end the session until after
you're done with the result set.</p>

<p>If you call setResultSetBufferSize() and forget what you set it to, you
can always call getResultSetBufferSize().</p>

<p>When buffering a result set in chunks, the rowCount() method returns
the number of rows returned so far.  The firstRowIndex() method returns the
index of the first row of the currently buffered chunk.

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cur</font> setResultSetBufferSize <font color="#ff00ff">2</font>

catch {<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;select * from testtable&quot;</font>}

<font color="#a52a2a"><b>set</b></font> row <font color="#ff00ff">0</font>
<font color="#a52a2a"><b>while</b></font> {true} {
        <font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> col <font color="#ff00ff">0</font>} {<font color="#008b8b">$col</font>&lt;[<font color="#008b8b">$cur</font> colCount]} {<font color="#a52a2a"><b>incr</b></font> col} {
                puts -nonewline [<font color="#008b8b">$cur</font> getFieldByIndex <font color="#008b8b">$row</font> <font color="#008b8b">$col</font>]
                puts -nonewline <font color="#ff00ff">&quot;,&quot;</font>
        }
        puts <font color="#ff00ff">&quot;&quot;</font>
        <font color="#a52a2a"><b>incr</b></font> row
        <font color="#a52a2a"><b>if</b></font> {[<font color="#008b8b">$cur</font> endOfResultSet]==<font color="#ff00ff">1</font> &amp;&amp; <font color="#008b8b">$row</font>==[<font color="#008b8b">$cur</font> rowCount]} {
                <font color="#a52a2a"><b>break</b></font>
        }
}
</pre>
</blockquote>

<a name="cursors"></a>
<span class="heading2">Cursors</span><br><br>

<p>Cursors make it possible to execute queries while processing the result
set of another query.  You can select rows from a table in one query, then 
iterate through it's result set, inserting rows into another table, using only 
1 database connection for both operations.</p>

<p>For example:</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cursor1 [<font color="#008b8b">$con</font> sqlrcur]
<font color="#a52a2a"><b>set</b></font> cursor2 [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cursor1</font> setResultSetBufferSize <font color="#ff00ff">10</font>
<font color="#008b8b">$cursor1</font> sendQuery <font color="#ff00ff">&quot;select * from my_huge_table&quot;</font>

<font color="#a52a2a"><b>set</b></font> <font color="#008b8b">$index</font> <font color="#ff00ff">0</font>
<font color="#a52a2a"><b>while</b></font> {[<font color="#008b8b">$cursor1</font> endOfResultSet] != <font color="#ff00ff">0</font>} {
        <font color="#008b8b">$cursor2</font> prepareQuery <font color="#ff00ff">&quot;insert into my_other_table values (:1,:2,:3)&quot;</font>
        <font color="#008b8b">$cursor2</font> inputBind <font color="#ff00ff">&quot;1&quot;</font> [<font color="#008b8b">$cursor1</font> getField <font color="#008b8b">$index</font> <font color="#ff00ff">1</font>]
        <font color="#008b8b">$cursor2</font> inputBind <font color="#ff00ff">&quot;2&quot;</font> [<font color="#008b8b">$cursor1</font> getField <font color="#008b8b">$index</font> <font color="#ff00ff">2</font>]
        <font color="#008b8b">$cursor2</font> inputBind <font color="#ff00ff">&quot;3&quot;</font> [<font color="#008b8b">$cursor1</font> getField <font color="#008b8b">$index</font> <font color="#ff00ff">3</font>]
        <font color="#008b8b">$cursor2</font> executeQuery
}
</blockquote>

<p>Prior to SQL Relay version 0.25, you would have had to buffer the first
result set or use 2 database connections instead of just 1.</p>

<p>If you are using stored procedures with Oracle 8i or higher, a stored
procedure can execute a query and return a cursor.  A cursor bind variable can
then retrieve that cursor.  Your program can retrieve the result set from the
cursor.  All of this can be accomplished using defineOutputBindCursor(),
getOutputBindCursor() and fetchFromOutputBindCursor().</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;begin  :curs:=sp_mytable; end;&quot;</font>
<font color="#008b8b">$cur</font> defineOutputBindCursor <font color="#ff00ff">&quot;curs&quot;</font>
<font color="#008b8b">$cur</font> executeQuery

<font color="#a52a2a"><b>set</b></font> bindcur [<font color="#008b8b">$cur</font> getOutputBindCursor <font color="#ff00ff">&quot;curs&quot;</font>]
<font color="#008b8b">$bindcur</font> fetchFromBindCursor

<font color="#0000ff"># print fields from table</font>
<font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> i <font color="#ff00ff">0</font>} {<font color="#008b8b">$i</font>&lt;[<font color="#008b8b">$bindcur</font> rowCount]} {<font color="#a52a2a"><b>incr</b></font> i} {
        <font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> j <font color="#ff00ff">0</font>} {<font color="#008b8b">$j</font>&lt;[<font color="#008b8b">$bindcur</font> colCount]} {<font color="#a52a2a"><b>incr</b></font> j} {
                puts [<font color="#008b8b">$bindcur</font> getField <font color="#008b8b">$i</font> <font color="#008b8b">$j</font>]
        }
}
</pre>
</blockquote>

<p>The number of cursors simultaneously available per-connection is set at 
compile time and defaults to 5.</p>

<a name="columns"></a>
<span class="heading2">Getting Column Information</span><br><br>

<p>For each column, the API supports getting the name, type and length of each
field.  All databases support these attributes.  The API also supports
getting the precision, scale, length of the longest field, and whether the
column is nullable, the primary key, unique, part of a key, unsigned,
zero-filled, binary, or an auto-incrementing field.  However, not all databases
support these attributes.  If a database doesn't support an attribute, it is
always returned as false.</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;select * from my_table&quot;</font>
<font color="#008b8b">$con</font> endSession

<font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> i <font color="#ff00ff">0</font>} {<font color="#008b8b">$i</font>&lt;[<font color="#008b8b">$cur</font> colCount]} {<font color="#a52a2a"><b>incr</b></font> i} {
        puts -nonewline <font color="#ff00ff">&quot;Name:          &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnName <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Type:          &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnTypeByIndex <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Length:        &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnLengthByIndex <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Precision:     &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnPrecisionByIndex <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Scale:         &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnScaleByIndex <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Longest Field: &quot;</font>
        puts [<font color="#008b8b">$cur</font> getLongestByIndex <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Nullable:      &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnIsNullableByIndex <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Primary Key:   &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnIsPrimaryKeyByIndex <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Unique:        &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnIsUniqueByIndex <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Part Of Key:   &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnIsPartOfKeyByIndex <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Unsigned:      &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnIsUnsignedByIndex <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Zero Filled:   &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnIsZeroFilledByIndex <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Binary:        &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnIsBinaryByIndex <font color="#008b8b">$i</font>]
        puts -nonewline <font color="#ff00ff">&quot;Auto Increment:&quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnIsAutoIncrementByIndex <font color="#008b8b">$i</font>]
}
</pre>
</blockquote>

<p>Some databases force column names to upper case, others force column names
to lower case, and others still support mixed-case column names.  Sometimes,
when migrating between databases, you can run into trouble.  You can use
upperCaseColumnNames() and lowerCaseColumnNames() to cause column names to be
converted to upper or lower case, or you can use mixedCaseColumnNames() to
cause column names to be returned in the same case as they are defined in the
database.</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -socket <font color="#ff00ff">&quot;&quot;</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font> -retrytime <font color="#ff00ff">0</font> -tries <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#0000ff"># column names will be forced to upper case</font>
<font color="#008b8b">$cur</font> upperCaseColumnNames
<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;select * from my_table&quot;</font>
<font color="#008b8b">$con</font> endSession

<font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> i <font color="#ff00ff">0</font>} {<font color="#008b8b">$i</font>&lt;[<font color="#008b8b">$cur</font> colCount]} {<font color="#a52a2a"><b>incr</b></font> i} {
        puts -nonewline <font color="#ff00ff">&quot;Name:          &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnName <font color="#008b8b">$i</font>]
}

<font color="#0000ff"># column names will be forced to lower case</font>
<font color="#008b8b">$cur</font> lowerCaseColumnNames
<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;select * from my_table&quot;</font>
<font color="#008b8b">$con</font> endSession

<font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> i <font color="#ff00ff">0</font>} {<font color="#008b8b">$i</font>&lt;[<font color="#008b8b">$cur</font> colCount]} {<font color="#a52a2a"><b>incr</b></font> i} {
        puts -nonewline <font color="#ff00ff">&quot;Name:          &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnName <font color="#008b8b">$i</font>]
}

<font color="#0000ff"># column names will be the same as they are in the database</font>
<font color="#008b8b">$cur</font> mixedCaseColumnNames
<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;select * from my_table&quot;</font>
<font color="#008b8b">$con</font> endSession

<font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> i <font color="#ff00ff">0</font>} {<font color="#008b8b">$i</font>&lt;[<font color="#008b8b">$cur</font> colCount]} {<font color="#a52a2a"><b>incr</b></font> i} {
        puts -nonewline <font color="#ff00ff">&quot;Name:          &quot;</font>
        puts [<font color="#008b8b">$cur</font> getColumnName <font color="#008b8b">$i</font>]
}
</pre>
</blockquote>


<a name="storedprocedures"></a>
<span class="heading2">Stored Procedures</span><br><br>

<p>Many databases support stored procedures.  Stored procedures are sets of
queries and procedural code that are executed inside of the database itself.
For example, a stored procedure may select rows from one table, iterate through
the result set and, based on the values in each row, insert, update or delete
rows in other tables.  A client program could do this as well, but a stored
procedure is generally more efficient because queries and result sets don't
have to be sent back and forth between the client and database.  Also, stored
procedures are generally stored in the database in a compiled state, while
queries may have to be re-parsed and re-compiled each time they are sent.</p>

<p>While many databases support stored procedures.  The syntax for creating
and executing stored procedures varies greatly between databases.</p>

<p>SQL Relay supports stored procedures for most databases, but there are
some caveats.  Stored procedures are not currently supported when using FreeTDS
against Sybase or Microsoft SQL Server.  Blob/Clob bind variables are only
supported in Oracle 8i or higher.  Sybase stored procedures must use varchar
output parameters.</p>

<p>Stored procedures typically take input paramters from client programs through
input bind variables and return values back to client programs either through
bind variables or result sets.  Stored procedures can be broken down into
several categories, based on the values that they return.  Some stored
procedures don't return any values, some return a single value, some return
multiple values and some return entire result sets.</p>

<span class="heading3">No Values</span><br>

<p>Some stored procedures don't return any values.  Below are examples,
illustrating how to create, execute and drop this kind of stored procedure for
each database that SQL Relay supports.</p>

<span class="heading4">Oracle</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">procedure</font> testproc(in1 <font color="#a52829"><b>in</b></font> <font color="#298a52"><b>number</b></font>, in2 <font color="#a52829"><b>in</b></font> <font color="#298a52"><b>number</b></font>, in3 <font color="#a52829"><b>in</b></font> <font color="#298a52"><b>varchar2</b></font>) <font color="#6b59ce">is</font>
<font color="#6b59ce">begin</font>
        <font color="#a52829"><b>insert</b></font> <font color="#6b59ce">into</font> mytable <font color="#6b59ce">values</font> (in1,in2,in3);
<font color="#6b59ce">end</font>;
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;begin testproc(:in1,:in2,:in3); end;&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> executeQuery
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>


<span class="heading4">Sybase and Microsoft SQL Server</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">procedure</font> testproc @in1 int, @in2 <font color="#298a52"><b>float</b></font>, @in3 <font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>) <font color="#6b59ce">as</font>
        <font color="#a52829"><b>insert</b></font> <font color="#6b59ce">into</font> mytable <font color="#6b59ce">values</font> (@in1,@in2,@in3)
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;exec testproc&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> executeQuery
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>

<span class="heading4">Interbase and Firebird</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">procedure</font> testproc(in1 <font color="#298a52"><b>integer</b></font>, in2 <font color="#298a52"><b>float</b></font>, in3 <font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>)) <font color="#6b59ce">as</font>
<font color="#6b59ce">begin</font>
        <font color="#a52829"><b>insert</b></font> <font color="#6b59ce">into</font> mytable <font color="#6b59ce">values</font> (in1,in2,in3);
        suspend;
<font color="#6b59ce">end</font>;
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;execute procedure testproc ?, ?, ?&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> executeQuery
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>

<span class="heading4">DB2</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">procedure</font> testproc(<font color="#a52829"><b>in</b></font> in1 int, <font color="#a52829"><b>in</b></font> in2 double, <font color="#a52829"><b>in</b></font> in3 <font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>)) language sql
<font color="#6b59ce">begin</font>
        <font color="#a52829"><b>insert</b></font> <font color="#6b59ce">into</font> mytable <font color="#6b59ce">values</font> (in1,in2,in3);
<font color="#6b59ce">end</font>;
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;call testproc(?,?,?)&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> executeQuery
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>

<span class="heading4">Postgresql</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">function</font> testproc(int,<font color="#298a52"><b>float</b></font>,<font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>)) returns void <font color="#6b59ce">as</font> '
<font color="#6b59ce">begin</font>
        <font color="#a52829"><b>insert</b></font> <font color="#6b59ce">into</font> mytable <font color="#6b59ce">values</font> ($<font color="#ff00ff">1</font>,$<font color="#ff00ff">2</font>,$<font color="#ff00ff">3</font>);
        <font color="#6b59ce">return</font>;
<font color="#6b59ce">end</font>;' language plpgsql
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;select testproc(:in1,:in2,:in3)&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> executeQuery
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>




<br><span class="heading3">Single Values</span><br>

<p>Some stored procedures return single values.  Below are examples,
illustrating how to create, execute and drop this kind of stored procedure for
each database that SQL Relay supports.</p>

<span class="heading4">Oracle</span><br>

<p>In Oracle, stored procedures can return values through output parameters or
as return values of the procedure itself.</p>

<p>Here is an example where the procedure itself returns a value.  Note that
Oracle calls these functions.</p>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">function</font> testproc(in1 <font color="#a52829"><b>in</b></font> <font color="#298a52"><b>number</b></font>, in2 <font color="#a52829"><b>in</b></font> <font color="#298a52"><b>number</b></font>, in3 <font color="#a52829"><b>in</b></font> <font color="#298a52"><b>varchar2</b></font>) returns <font color="#298a52"><b>number</b></font> <font color="#6b59ce">is</font>
<font color="#6b59ce">begin</font>
        <font color="#6b59ce">return</font> in1;
<font color="#6b59ce">end</font>;
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;select testproc(:in1,:in2,:in3) from dual&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> result [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">0</font> <font color="#ff00ff">0</font>]
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">function</font> testproc
</pre>
</blockquote>

<p>Here is an example where the value is returned through an output
parameter.</p>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">procedure</font> testproc(in1 <font color="#a52829"><b>in</b></font> <font color="#298a52"><b>number</b></font>, in2 <font color="#a52829"><b>in</b></font> <font color="#298a52"><b>number</b></font>, in3 <font color="#a52829"><b>in</b></font> <font color="#298a52"><b>varchar2</b></font>, out1 <font color="#a52829"><b>out</b></font> <font color="#298a52"><b>number</b></font>) <font color="#6b59ce">as</font>
<font color="#6b59ce">begin</font>
        out1:=in1;
<font color="#6b59ce">end</font>;
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;begin testproc(:in1,:in2,:in3,:out1); end;&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;out1&quot;</font> <font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> result [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;out1&quot;</font>]
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>


<span class="heading4">Sybase and Microsoft SQL Server</span><br>

<p>In Sybase and Microsoft SQL Server, stored procedures return values
through output parameters rather than as return values of the procedure
itself.</p>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">procedure</font> testproc @in1 int, @in2 <font color="#298a52"><b>float</b></font>, @in3 <font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>), @out1 int output <font color="#6b59ce">as</font>
        <font color="#a52829"><b>select</b></font> @out1=convert(<font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>),@in1)
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;exec testproc&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in1&quot;</font>,<font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in2&quot;</font>,<font color="#ff00ff">1.1</font>,<font color="#ff00ff">2</font>,<font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in3&quot;</font>,<font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;out1&quot;</font>,<font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> result [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;out1&quot;</font>]
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>


<span class="heading4">Interbase and Firebird</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">procedure</font> testproc(in1 <font color="#298a52"><b>integer</b></font>, in2 <font color="#298a52"><b>float</b></font>, in3 <font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>)) returns (out1 <font color="#298a52"><b>integer</b></font>) <font color="#6b59ce">as</font>
<font color="#6b59ce">begin</font>
        out1=in1;
        suspend;
<font color="#6b59ce">end</font>;
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;select * from testproc(?,?,?)&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> result [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">0</font> <font color="#ff00ff">0</font>]
</pre>
</blockquote>

<p>Alternatively, you can run a query like the following and receive the result
using an output bind variable.  Note that in Interbase/Firebird, input and
output bind variable indices are distict from one another.  The index of the
output bind variable is 1 rather than 4, even though there were 3 input bind
variables.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;execute procedure testproc ?, ?, ?&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;1&quot;</font> <font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> result [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;1&quot;</font>]
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>


<span class="heading4">DB2</span><br>

<p>In DB2, stored procedures return values through output parameters rather
than as return values of the procedure itself.</p>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">procedure</font> testproc(<font color="#a52829"><b>in</b></font> in1 int, <font color="#a52829"><b>in</b></font> in2 double, <font color="#a52829"><b>in</b></font> in3 <font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>), <font color="#a52829"><b>out</b></font> out1 int) language sql
<font color="#6b59ce">begin</font>
        <font color="#a52829"><b>set</b></font> out1 = in1;
<font color="#6b59ce">end</font>
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;call testproc(?,?,?,?)&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;4&quot;</font> <font color="#ff00ff">25</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> result [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;4&quot;</font>]
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>


<span class="heading4">Postgresql</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">function</font> testfunc(int,<font color="#298a52"><b>float</b></font>,<font color="#298a52"><b>char</b></font>(<font color="#ff00ff">20</font>)) returns int <font color="#6b59ce">as</font> '
declare
        in1 int;
        in2 <font color="#298a52"><b>float</b></font>;
        in3 <font color="#298a52"><b>char</b></font>(<font color="#ff00ff">20</font>);
<font color="#6b59ce">begin</font>
        in1:=$<font color="#ff00ff">1</font>;
        <font color="#6b59ce">return</font>;
<font color="#6b59ce">end</font>;
' language plpgsql
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;select * from testfunc(:in1,:in2,:in3)&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">4</font> <font color="#ff00ff">2</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> result [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">0</font> <font color="#ff00ff">0</font>]
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">function</font> testfunc(int,<font color="#298a52"><b>float</b></font>,<font color="#298a52"><b>char</b></font>(<font color="#ff00ff">20</font>))
</pre>
</blockquote>



<br><span class="heading3">Multiple Values</span><br>

<p>Some stored procedures return multiple values.  Below are examples,
illustrating how to create, execute and drop this kind of stored procedure for
each database that SQL Relay supports.</p>

<span class="heading4">Oracle</span><br>

<p>In Oracle, stored procedures can return values through output parameters or
as return values of the procedure itself.  If a procedure needs to return
multiple values, it can return one of them as the return value of the procedure
itself, but the rest must be returned through output parameters.</p>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">procedure</font> testproc(in1 <font color="#a52829"><b>in</b></font> <font color="#298a52"><b>number</b></font>, in2 <font color="#a52829"><b>in</b></font> <font color="#298a52"><b>number</b></font>, in3 <font color="#a52829"><b>in</b></font> <font color="#298a52"><b>varchar2</b></font>, out1 <font color="#a52829"><b>out</b></font> <font color="#298a52"><b>number</b></font>, out2 <font color="#a52829"><b>out</b></font> <font color="#298a52"><b>number</b></font>, out3 <font color="#a52829"><b>out</b></font> <font color="#298a52"><b>varchar2</b></font>) <font color="#6b59ce">is</font>
<font color="#6b59ce">begin</font>
        out1:=in1;
        out2:=in2;
        out3:=in3;
<font color="#6b59ce">end</font>;
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;begin testproc(:in1,:in2,:in3,:out1,:out2,:out3); end;&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;out1&quot;</font> <font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;out2&quot;</font> <font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;out3&quot;</font> <font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> out1 [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;out1&quot;</font>]
<font color="#a52a2a"><b>set</b></font> out2 [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;out2&quot;</font>]
<font color="#a52a2a"><b>set</b></font> out3 [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;out3&quot;</font>]
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>


<span class="heading4">Sybase and Microsoft SQL Server</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">procedure</font> testproc @in1 int, @in2 <font color="#298a52"><b>float</b></font>, @in3 <font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>), @out1 int output, @out2 int output, @out3 int output <font color="#6b59ce">as</font>
        <font color="#a52829"><b>select</b></font> @out1=convert(<font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>),@in1),
                @out2=convert(<font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>),@in2),
                @out2=convert(<font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>),@in2)
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;exec testproc&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in1&quot;</font>,<font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in2&quot;</font>,<font color="#ff00ff">1.1</font>,<font color="#ff00ff">2</font>,<font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in3&quot;</font>,<font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;out1&quot;</font>,<font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;out2&quot;</font>,<font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;out3&quot;</font>,<font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> out1 [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;out1&quot;</font>]
<font color="#a52a2a"><b>set</b></font> out2 [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;out2&quot;</font>]
<font color="#a52a2a"><b>set</b></font> out3 [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;out3&quot;</font>]
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>


<span class="heading4">Interbase and Firebird</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">procedure</font> testproc(in1 <font color="#298a52"><b>integer</b></font>, in2 <font color="#298a52"><b>float</b></font>, in3 <font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>)) returns (out1 <font color="#298a52"><b>integer</b></font>, out2 <font color="#298a52"><b>float</b></font>, out3 <font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>)) <font color="#6b59ce">as</font>
<font color="#6b59ce">begin</font>
        out1=in1;
        out2=in2;
        out3=in3;
        suspend;
<font color="#6b59ce">end</font>;
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;select * from testproc(?,?,?)&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">4</font> <font color="#ff00ff">2</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> out1 [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">0</font> <font color="#ff00ff">0</font>]
<font color="#a52a2a"><b>set</b></font> out2 [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">0</font> <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> out3 [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">0</font> <font color="#ff00ff">2</font>]
</pre>
</blockquote>

<p>Alternatively, you can run a query like the following and receive the result
using a output bind variables.  Note that in Interbase/Firebird, input and
output bind variable indices are distict from one another.  The index of the
first output bind variable is 1 rather than 4, even though there were 3 input
bind variables.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;execute procedure testproc ?, ?, ?&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;1&quot;</font> <font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;2&quot;</font> <font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;3&quot;</font> <font color="#ff00ff">20</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> out1 [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;1&quot;</font>]
<font color="#a52a2a"><b>set</b></font> out2 [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;2&quot;</font>]
<font color="#a52a2a"><b>set</b></font> out3 [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;3&quot;</font>]
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>


<span class="heading4">DB2</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">procedure</font> testproc(<font color="#a52829"><b>in</b></font> in1 int, <font color="#a52829"><b>in</b></font> in2 double, <font color="#a52829"><b>in</b></font> in3 <font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>), <font color="#a52829"><b>out</b></font> out1 int, <font color="#a52829"><b>out</b></font> out2 double, <font color="#a52829"><b>out</b></font> out3 <font color="#298a52"><b>varchar</b></font>(<font color="#ff00ff">20</font>)) language sql
<font color="#6b59ce">begin</font>
        <font color="#a52829"><b>set</b></font> out1 = in1;
        <font color="#a52829"><b>set</b></font> out2 = in2;
        <font color="#a52829"><b>set</b></font> out3 = in3;
<font color="#6b59ce">end</font>
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;call testproc(?,?,?,?,?,?)&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">2</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;4&quot;</font> <font color="#ff00ff">25</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;5&quot;</font> <font color="#ff00ff">25</font>
<font color="#008b8b">$cur</font> defineOutputBind <font color="#ff00ff">&quot;6&quot;</font> <font color="#ff00ff">25</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> out1 [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;4&quot;</font>]
<font color="#a52a2a"><b>set</b></font> out2 [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;5&quot;</font>]
<font color="#a52a2a"><b>set</b></font> out3 [<font color="#008b8b">$cur</font> getOutputBind <font color="#ff00ff">&quot;6&quot;</font>]
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">procedure</font> testproc
</pre>
</blockquote>


<span class="heading4">Postgresql</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">function</font> testfunc(int,<font color="#298a52"><b>float</b></font>,<font color="#298a52"><b>char</b></font>(<font color="#ff00ff">20</font>)) returns record <font color="#6b59ce">as</font> '
declare
        output record;
<font color="#6b59ce">begin</font>
        <font color="#a52829"><b>select</b></font> $<font color="#ff00ff">1</font>,$<font color="#ff00ff">2</font>,$<font color="#ff00ff">3</font> <font color="#6b59ce">into</font> output;
        <font color="#6b59ce">return</font> output;
<font color="#6b59ce">end</font>;
' language plpgsql
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;select * from testfunc(:in1,:in2,:in3) as (col1 int, col2 float, col3 char(20))&quot;</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in1&quot;</font> <font color="#ff00ff">1</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in2&quot;</font> <font color="#ff00ff">1.1</font> <font color="#ff00ff">4</font> <font color="#ff00ff">2</font>
<font color="#008b8b">$cur</font> inputBind <font color="#ff00ff">&quot;in3&quot;</font> <font color="#ff00ff">&quot;hello&quot;</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> out1 [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">0</font> <font color="#ff00ff">0</font>]
<font color="#a52a2a"><b>set</b></font> out2 [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">0</font> <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> out3 [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">0</font> <font color="#ff00ff">2</font>]
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">function</font> testfunc(int,<font color="#298a52"><b>float</b></font>,<font color="#298a52"><b>char</b></font>(<font color="#ff00ff">20</font>))
</pre>
</blockquote>



<br><span class="heading3">Result Sets</span><br>

<p>Some stored procedures return entire result sets.  Below are examples,
illustrating how to create, execute and drop this kind of stored procedure for
each database that SQL Relay supports.</p>

<span class="heading4">Oracle</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#a52829"><b>or</b></font> replace package types <font color="#6b59ce">as</font>
        <font color="#6b59ce">type</font> cursorType <font color="#6b59ce">is</font> ref <font color="#6b59ce">cursor</font>;
<font color="#6b59ce">end</font>;

<font color="#a52829"><b>create</b></font> <font color="#6b59ce">function</font> testproc <font color="#6b59ce">return</font> types.cursortype <font color="#6b59ce">is</font>
        l_cursor    types.cursorType;
<font color="#6b59ce">begin</font>
        open l_cursor <font color="#6b59ce">for</font> <font color="#a52829"><b>select</b></font> * <font color="#6b59ce">from</font> mytable;
        <font color="#6b59ce">return</font> l_cursor;
<font color="#6b59ce">end</font>;
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> prepareQuery <font color="#ff00ff">&quot;begin  :curs:=testproc; end;&quot;</font>
<font color="#008b8b">$cur</font> defineOutputBindCursor <font color="#ff00ff">&quot;curs&quot;</font>
<font color="#008b8b">$cur</font> executeQuery
<font color="#a52a2a"><b>set</b></font> bindcur [<font color="#008b8b">$cur</font> getOutputBindCursor <font color="#ff00ff">&quot;curs&quot;</font>]
<font color="#008b8b">$bindcur</font> fetchFromBindCursor
<font color="#a52a2a"><b>set</b></font> field00 [<font color="#008b8b">$bindcur</font> getField <font color="#ff00ff">0</font> <font color="#ff00ff">0</font>]
<font color="#a52a2a"><b>set</b></font> field01 [<font color="#008b8b">$bindcur</font> getField <font color="#ff00ff">0</font> <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> field02 [<font color="#008b8b">$bindcur</font> getField <font color="#ff00ff">0</font> <font color="#ff00ff">2</font>]
<font color="#a52a2a"><b>set</b></font> field10 [<font color="#008b8b">$bindcur</font> getField <font color="#ff00ff">1</font> <font color="#ff00ff">0</font>]
<font color="#a52a2a"><b>set</b></font> field11 [<font color="#008b8b">$bindcur</font> getField <font color="#ff00ff">1</font> <font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> field12 [<font color="#008b8b">$bindcur</font> getField <font color="#ff00ff">1</font> <font color="#ff00ff">2</font>]
...
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">function</font> testproc
<font color="#a52829"><b>drop</b></font> package types
</pre>
</blockquote>


<span class="heading4">Sybase and Microsoft SQL Server</span><br>

<p>Stored procedures in Sybase and Microsoft SQL Server can return a result
set if the last command in the procedure is a select query, however SQL Relay
doesn't currently support stored procedures that return result sets.</p>


<span class="heading4">Interbase and Firebird</span><br>

<p>Stored procedures in Interbase and Firebird can return a result set if a
select query in the procedure selects values into the output parameters and
then issues a suspend command, however SQL Relay doesn't currently support
stored procedures that return result sets.</p>

<span class="heading4">DB2</span><br>

<p>Stored procedures in DB2 can return a result set if the procedure is declared
to return one, however SQL Relay doesn't currently support stored procedures
that return result sets.</p>

<span class="heading4">Postgresql</span><br>

<p>To create the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>create</b></font> <font color="#6b59ce">function</font> testfunc() returns setof record <font color="#6b59ce">as</font> '
        declare output record;
<font color="#6b59ce">begin</font>
        <font color="#6b59ce">for</font> output <font color="#a52829"><b>in</b></font> <font color="#a52829"><b>select</b></font> * <font color="#6b59ce">from</font> mytable <font color="#6b59ce">loop</font>
                <font color="#6b59ce">return</font> next output;
        <font color="#6b59ce">end</font> <font color="#6b59ce">loop</font>;
        <font color="#6b59ce">return</font>;
<font color="#6b59ce">end</font>;
' language plpgsql
</pre>
</blockquote>

<p>To execute the stored procedure from an SQL Relay program, use code like the
following.</p>

<blockquote>
<pre>
<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;select * from testfunc() as (testint int, testfloat float, testchar char(40))&quot;</font>
<font color="#a52a2a"><b>set</b></font> field00 [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">0</font>,<font color="#ff00ff">0</font>]
<font color="#a52a2a"><b>set</b></font> field01 [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">0</font>,<font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> field02 [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">0</font>,<font color="#ff00ff">2</font>]
<font color="#a52a2a"><b>set</b></font> field10 [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">1</font>,<font color="#ff00ff">0</font>]
<font color="#a52a2a"><b>set</b></font> field11 [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">1</font>,<font color="#ff00ff">1</font>]
<font color="#a52a2a"><b>set</b></font> field12 [<font color="#008b8b">$cur</font> getField <font color="#ff00ff">1</font>,<font color="#ff00ff">2</font>]
...
</pre>
</blockquote>

<p>To drop the stored procedure, run a query like the following.</p>

<blockquote>
<pre>
<font color="#a52829"><b>drop</b></font> <font color="#6b59ce">function</font> testfunc
</pre>
</blockquote>


<a name="caching"></a>
<span class="heading2">Caching The Result Set</span><br><br>

<p>Say you're writing a web-based report where a query with a huge result set
is executed and 20 rows are displayed per page.  Rather than rerunning the 
query for every page every time and dumping all but the 20 rows you want to
display, you can run the query once, cache the result set to a local file and
just open the file for each page of the report.</p>

<p>First CGI:</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

        ... generate a unique file name ...

<font color="#008b8b">$cur</font> cacheToFile <font color="#008b8b">$filename</font>
<font color="#008b8b">$cur</font> setCacheTtl <font color="#ff00ff">600</font>
<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;select * from my_table&quot;</font>
<font color="#008b8b">$con</font> endSession
<font color="#008b8b">$cur</font> cacheOff

        ... pass the filename to the next page ...
</pre>
</blockquote>

<p>Second CGI:</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

        ... get the filename from the previous page ...

        ... get the page to display from the previous page ...

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cur</font> openCachedResultSet <font color="#008b8b">$filename</font>
<font color="#008b8b">$con</font> endSession

<font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> row [<font color="#a52a2a"><b>expr</b></font> <font color="#008b8b">$pagetodisplay</font> * <font color="#ff00ff">20</font>]} {<font color="#008b8b">$row</font>&lt;[<font color="#a52a2a"><b>expr</b></font> [<font color="#a52a2a"><b>expr</b></font> <font color="#008b8b">$pagetodisplay</font> + <font color="#ff00ff">1</font>] * <font color="#ff00ff">20</font>]} {<font color="#a52a2a"><b>incr</b></font> row} {
        <font color="#a52a2a"><b>for</b></font> {<font color="#a52a2a"><b>set</b></font> col <font color="#ff00ff">0</font>} {<font color="#008b8b">$col</font>&lt;[<font color="#008b8b">$cur</font> colCount]} {<font color="#a52a2a"><b>incr</b></font> col} {
                puts -nonewline <font color="#008b8b">$cur</font> getField <font color="#008b8b">$row</font> <font color="#008b8b">$col</font>
                puts -nonewline <font color="#ff00ff">&quot;,&quot;</font>
        }
        puts <font color="#ff00ff">&quot;&quot;</font>
}
</pre>
</blockquote>


<a name="suspending"></a>
<span class="heading2">Suspending and Resuming Sessions</span><br><br>

<p>Sometimes web-based applications need a single database transaction to span
multiple pages.  Since SQL Relay sessions can be suspended and resumed, this
is possible.</p>

<p>First CGI:</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;insert into my_table values (1,2,3)&quot;</font>
<font color="#a52a2a"><b>set</b></font> <font color="#008b8b">$port</font> [<font color="#008b8b">$cur</font> getConnectionPort]
<font color="#a52a2a"><b>set</b></font> <font color="#008b8b">$cusocket</font> [<font color="#008b8b">$cur</font> getConnectionSocket]
<font color="#a52a2a"><b>set</b></font> <font color="#008b8b">$rs</font> [<font color="#008b8b">$cur</font> getResultSetId]
<font color="#008b8b">$cur</font> suspendResultSet
<font color="#008b8b">$con</font> suspendSession

        ... pass the rs, port and socket to the next page ...
</pre>
</blockquote>

<p>Second CGI:</p>

<blockquote>
<pre>
load /usr/lib/sqlrelay/sqlrelay.so sqlrelay

        ... get rs, port and socket from previous page ...

<font color="#a52a2a"><b>set</b></font> con [sqlrcon -server <font color="#ff00ff">&quot;host&quot;</font> -port <font color="#ff00ff">9000</font> -user <font color="#ff00ff">&quot;user&quot;</font> -password <font color="#ff00ff">&quot;password&quot;</font>]
<font color="#a52a2a"><b>set</b></font> cur [<font color="#008b8b">$con</font> sqlrcur]

<font color="#008b8b">$con</font> resumeSession <font color="#008b8b">$port</font> <font color="#008b8b">$socket</font>
<font color="#008b8b">$cur</font> resumeResultSet <font color="#008b8b">$rs</font>
<font color="#008b8b">$cur</font> sendQuery <font color="#ff00ff">&quot;commit&quot;</font>
<font color="#008b8b">$con</font> endSession
</pre>
</blockquote>

<p>You can also distribute the processing of a result set across a series of
CGI's using suspended sessions.  If you're buffering a result set in chunks
instead of all at once and suspend a session, when you resume the session you 
can continue to retrieve rows from the result set.</p>

<p>Similarly, if you're buffering a result set in chunks, caching that
result set and suspend your session.  When you resume the session, you can
continue caching the result set.  You must use resumeCachedResultSet()
instead of resumeResultSet() however.</p>

</body>
</html>

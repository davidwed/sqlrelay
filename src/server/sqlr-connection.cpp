// Copyright (c) 1999-2010  David Muse
// See the file COPYING for more information

#include <config.h>
#include <sqlrcontroller.h>
#include <rudiments/process.h>
#include <rudiments/signalclasses.h>
#include <rudiments/stdio.h>

sqlrcontroller_svr	*cont=NULL;
volatile sig_atomic_t	shutdowninprogress=0;
signalhandler		shutdownhandler;

void cleanUp() {
	cont->closeConnection();
	delete cont;
}

void shutDown(int32_t signum) {

	if (!signalhandler::isSignalHandlerIntUsed()) {
		cleanUp();
		process::exit(0);
	}

	// Since this handler is established for more than one kind of signal,
	// it might still get invoked recursively by delivery of some other kind
	// of signal.  Use a static variable to keep track of that.
	if (shutdowninprogress) {
		return;
	}
	shutdowninprogress=1;

	int	exitcode=1;
	switch (signum) {
		case SIGINT:
		#ifdef HAVE_SIGQUIT
		case SIGQUIT:
		#endif
			// These signals indicate normal termination
			stderror.printf("(pid=%ld) Process terminated "
					"with signal %d\n",
					(long)process::getProcessId(),signum);
			break;

		case SIGTERM:
			// Shutdown
		#ifdef HAVE_SIGALRM
		case SIGALRM:
			// Timeout
			stderror.printf("(pid=%ld) Process terminated "
					"with signal %d\n",
					(long)process::getProcessId(),signum);
			exitcode=0;
			break;
		#endif

		default:
			// Other signals are bugs
			stderror.printf("(pid=%ld) Abnormal termination: "
					"signal %d received\n",
					(long)process::getProcessId(),signum);
			cleanUp();
			// Now reraise the signal.  We reactivate the signal's
		   	// default handling, which is to terminate the process.
		   	// We could just call exit or abort,
		   	// but reraising the signal sets the return status
		   	// from the process correctly.
			signal(signum,SIG_DFL);
			signalmanager::raiseSignal(signum);
	}

	cleanUp();
	process::exit(exitcode);
}

void handleSignals(void (*shutdownfunction)(int32_t)) {

	// handle kill (SIGINT, SIGTERM) and crash (SIGSEGV) signals
	process::handleShutDown(shutdownfunction);
	process::handleCrash(shutdownfunction);

	// handle various other shutdown conditions
	shutdownhandler.setHandler(shutdownfunction);
	// timeouts
	#ifdef HAVE_SIGALRM
		shutdownhandler.handleSignal(SIGALRM);
	#endif
	// quit
	#ifdef HAVE_SIGQUIT
		shutdownhandler.handleSignal(SIGQUIT);
	#endif
	// This signal is generated when an invalid pointer is dereferenced.
	#ifdef HAVE_SIGBUS
		shutdownhandler.handleSignal(SIGBUS);
	#endif
	// fatal arithmetic error
	#ifdef HAVE_SIGFPE
		shutdownhandler.handleSignal(SIGFPE);
	#endif
	// trying to execute garbage or a privileged instruction
	#ifdef HAVE_SIGILL
		shutdownhandler.handleSignal(SIGILL);
	#endif
	// calling abort
	#ifdef HAVE_SIGABRT
		shutdownhandler.handleSignal(SIGABRT);
	#endif
	// Generated by the PDP-11 “iot” instruction.
	// On most machines, this is just another name for SIGABRT
	#ifdef HAVE_SIGIOT
		shutdownhandler.handleSignal(SIGIOT);
	#endif
	// program will probably only see SIGTRAP if it
	// is somehow executing bad instructions
	#ifdef HAVE_SIGTRAP
		shutdownhandler.handleSignal(SIGTRAP);
	#endif
	// unimplemented instructions which might be emulated in software
	#ifdef HAVE_SIGEMT
		shutdownhandler.handleSignal(SIGEMT);
	#endif
	// Bad system call
	#ifdef HAVE_SIGSYS
		shutdownhandler.handleSignal(SIGSYS);
	#endif
	// CPU consumption "soft limit"
	#ifdef HAVE_SIGXCPU
		shutdownhandler.handleSignal(SIGXCPU);
	#endif
	// File size limit exceeded
	#ifdef HAVE_SIGXFSZ
		shutdownhandler.handleSignal(SIGXFSZ);
	#endif
	// power failure
	#ifdef HAVE_SIGPWR
		shutdownhandler.handleSignal(SIGPWR);
	#endif

	// ignore others
	signalset	set;
	set.removeAllSignals();

	// HangUp
	#ifdef HAVE_SIGHUP
		set.addSignal(SIGHUP);
	#endif
	// Operation Error Signals
	#ifdef HAVE_SIGPIPE
		set.addSignal(SIGPIPE);
	#endif
	#ifdef HAVE_SIGLOST
		set.addSignal(SIGLOST);
	#endif
	// Miscellaneous Signals
	#ifdef HAVE_SIGTTIN
		set.addSignal(SIGTTIN);
	#endif
	#ifdef HAVE_SIGTTOU
		set.addSignal(SIGTTOU);
	#endif
	#ifdef HAVE_SIGVTALRM
		set.addSignal(SIGVTALRM);
	#endif
	#ifdef HAVE_SIGPROF
		set.addSignal(SIGPROF);
	#endif
	#ifdef HAVE_SIGIO
		set.addSignal(SIGIO);
	#endif
	#ifdef HAVE_SIGPOLL
		set.addSignal(SIGPOLL);
	#endif
	signalmanager::ignoreSignals(&set);
}

int main(int argc, const char **argv) {

	// set up default signal handling
	process::exitOnCrashOrShutDown();

	#include <version.h>

	// create the controller
	cont=new sqlrcontroller_svr;

	// handle signals more particularly
	handleSignals(shutDown);

	// connect to the db
	bool	result=cont->init(argc,argv);
	if (result) {
		// wait for client connections
		result=cont->listen();
	}

	// If sqlr-stop has been run, we may be here because the sqlr-listener
	// has been killed.  In that case, we'll get a SIGINT soon, but we
	// want to ignore it and just let the shutdown proceed normally,
	// otherwise we could be halfway through cleanUp() below when we
	// get it, which will ultimately run cleanUp() again and result in
	// double-free's and a crash.  If we happen to receive the SIGINT
	// before this point, then the shutdown will proceed that way.
	shutdowninprogress=1;

	// unsuccessful completion
	cleanUp();

	// return successful or unsuccessful completion based on listenresult
	process::exit((result)?0:1);
}

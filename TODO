#2 - in/out binds
Is it possible to bind to in/out parameters?  If so, document it, if not, make it work somehow.



#3 - clean up leftover PID/socket files somehow



#4 - unify bind architecture
* unify bind architecture
 * all connections use MAXVAR and similar logic
 * push some logic up into sqlrcursor_svr class


#5 - sem(8) in scaler
we might be able to do without sem(8) in the scaler since the scaler knows how many connections it has started and killed



#6 - reset autocommit
reset autocommit state when new client logs into sqlrelay



#9 - listen() backlog
On systems which have a large listen() backlog, just let client connections pile up, rather than forking a child to handle them.

Linux:
* when using syn cookies, there is no maximum backlog length
* not sure for 2.6 or newer kernels
* on 2.2/2.4, /proc/sys/net/ipv4/tcp_max_syn_backlog controls the backlog length.  The default is 1024 for systems with more than 128Mb of memory, and 128 for low memory machines.  If you make it greater than 1024, change TCP_SYNQ_HSIZE in include/net/tcp.h to keep TCP_SYNQ_HSIZE*16<=tcp_max_syn_backlog and recompile kernel.
* on 2.0, the max backlog is 128

Solaris:
* set backlog length using: /usr/sbin/ndd -set /dev/tcp tcp_conn_req_max 32

Not sure on other platforms.


#10 - client connect timeout
Add parameters to client api's to allow a connect timeout.  Expose these through sqlrsh as well.


#11 - encrypted passwords
store passwords in an encrypted form in the sqlrelay.conf file


#13 - column flag bitmap
implement the column flags as a bitmap


#14 - persistent cursors
Parse query, attach an id to it, make it available to other sessions.

eg:

cur->prepareQuery("select * from table where col=?");
uint64_t id=cur->persistQuery();

Then id is made available to other processes which can run something like:

cur->usePersistentQuery(id);
cur->inputBind("1","blah");
cur->executeQuery();

Alternatively, a set of queries could be defined in a config file and could just be referred to by id.


#15 - IPC-based communication
Client-server communication could be done through shared memory buffers rather than over unix sockets.


#16 - API methods to use preallocated buffers
Currently the client has an internal buffer, preallocated to an "optimistic" size and grows it as necessary.  However, it could be more efficient not to have a buffer, allow the app to supply one, and just fill it, similar to how the OCI API works.

eg:

char field1[100];
char field2[20];

cur->executeQuery("select * from table");
cur->getField(0,0,field1,sizeof(field1));
cur->getField(0,1,field2,sizeof(field2));


#17 - API methods to configure optimistic buffer sizes
Provide API methods to configure and reconfigure the size of the internal preallocated buffers.


#18 - compression
Option to compress/decompress the client-server communication.


#19 - Server Side Result Set Cache
Cache result sets on the server with TTL, like client side caching has.  Provide client-side methods to access the cache.


#20 - Batch DML
Some DB's, definitely Oracle, possibly others, allow you to prepare an insert, update or delete and send it to the db with a 2d array of bind variables.  The query is then prepared once and then executed for each row of bind data.  Success or failure is only reported at the end.  There is no need to execute queries individually and wait for the result of each.  It dramatically reduces round trips to the server.

Even for db's that don't support this, SQL Relay couldd and we could reduce round trips between the SQL Relay client and server.

Should have an option for how many failures to tolerate before stopping altogether.


#21 - non-string results
If a field is a number, send it to the client as a number, rather than converting to a string and sending that.  This will reduce network traffic.

Some db's support this themselves.  Others do not.  For those that don't, the cost of the string->number->string conversion might outweigh the bandwidth savings.  We'll have to evaluate that.


#22 - separate modules
Split modules out into individual components that can be built and maintained separately, similar to what was done with X.org.

Perl, Python, Ruby, etc. api code could then be moved to CPAN, PECL, etc. and housed there rather than with the main distro.

There are pros and cons to this.  I'm not 100% sure it should be done.


#23 - plugin-based sqlr-connection
Rather than compiling separate binaries for each database, have a single sqlr-connection binary that dlopen's the appropriate driver for each db.


#24 - login errors
login errors should be printed on the screen by sqlrconnection class, not by individual connections



#25 - asynchronous queries
API for running queries in the background, methods to see if they're done, wait for the result, abort, etc.

Eg:

cur1->prepareQuery("select * from table1");
cur2->prepareQuery("select * from table2");
cur1->executeQueryAsync();
cur2->executeQueryAsync();

... do some local work while queries are running...

for (;;) {

  sqlrcur *readycur=con->queryFinished();

  ... process result set of query that finished ...
}


Also, there could be methods like:

for (;;) {

  if (cur1->queryFinished()) {
    ... process result set ...
  } else if (cur2->queryFinished()) {
    ... process result set ...
  }

  ... otherwise do some local work and/or sleep ...

  if (thisistakingtoolong) {
     cur1->abort();
     cur2->abort();
  } 
}

Or...

cur->waitForQuery(timeout) which waits some amount of time for a query to finish, with a timeout

And...

con->waitForQueries(timeout) which waits for any of the queries for this connection to finish, with a timeout

Arguably there should be some way to get the low-level file descriptor as well, so a general select() or the listener class could be used to wait on queries across multiple connections in addition to other things.


#26 - bandwidth delay product
Use the bandwidth delay product to set tcp send/receive buffer sizes.


#27 - ODBC client - numeric binds
ODBC requires numbers rather than names for bind variables, make sure docs for the ODBC client say that you have to use numbers


#28 - SQL Relay - Joomla doc
document how to use SQL Relay with Joomla, if that's even possible


#29 - document perl DBI clob/blob binds
Document how to do clob/blob binds against Oracle using the Perl DBI api.


#31 - How SQL Relay Works Doc
Develop a How SQL Relay Works document with diagrams and animations.


#32 - example sqlrelay.conf files
Publish example sqlrelay.conf files for common configurations and scenarios.


#33 - Benchmark Charts
Develop and publish benchmark charts for SQL Relay vs. native databases in a variety of situations, as well as for the various tuning options.


#34 - nobody user/group issues
Document the various issues that can come up when using nobody as the user/group for running SQL Relay.


#35 - consolodate command line clients
Roll functionality of query, fields and sqltodbf into sqlrsh.


#36 - xml output
make xml output an option in sqlrsh


#37 - Oracle long/lob
Support the legacy oracle "long" datatype in the same way that a lob is supported now.


#38 - DTD -> Schema
Convert the sqlrelay.dtd file to an xml schema file.


#39 - ODBC Driver
Get the ODBC driver working well enough for production and well enough to be used with the ODBC-JDBC brige.


#40 - Perl DBI binds
Perl DBI driver needs to convert bind vars from ?'s to db-appropriate format like PHP Pear DB driver does



#41 - cursor close method
Non C/C++ api's need a method to close cursors.  Specifically, bind cursors cannot be closed manually and must be garbage collected.  It's not an issue for memory, but rather a server-side cursor will be occupied until it's garbage collected.  On C/C++ you can just delete it.



#42 - error code
Currently, SQL Relay passes the native database error string back, but not the error number.  Pass the error number back as well.


#43 - SSL Support
Full client-server SSL support:
* encryption
* cert-based validation of both sides
* key-based authentication


#44 - verbose export/import
Have a verbose mode for sqlr-export/sqlr-import that reports progress.


#45 - user-based query routing
Access different db's depending on the user/password used to log into sqlrelay.


#46 - query rewriting
regex-based query rewriting:
if m/select blah from AAA[01|02|03].table/ then s/AAA[01|02|03]/AAA/g


#47 - sqlrelay.conf-configurable fetch buffer sizes
Make fetch-buffer sizes run-time configurable in sqlrelay.conf for DB2 and sybase like they are for oracle.


#48 - client-configurable fetch buffer sizes
Make the fetch-buffer sizes re-configurable on the fly via client calls.


#49 - quoting method call
Add a "quoting method" call to api, call mysql native function, (mysql_escape_string()/mysql_real_escape_string())


#50 - sqlite binds
Support native (non-faked) binds with sqlite.


#51 - sqlite utf-8/utf-16 functions
support the sqlite utf-8/utf-16 functions


#52 - Zope Bind Variables
Does Zope support bind variables somehow?  If it does, update the driver to use them.


#53 - 2-phase commit
Add 2-phase commit to API.  Implement it for databases that support it.  Use it in the query router.


#54 - PAM authentication
Use PAM as an alternative to just having users and passwords in the config file.


#57 - logrotate
make logs logrotate compatible, if they aren't already


#58 - ct_con_prop/encryption
Support freetds/sybase ct_con_prop/encryption functions.  Provide configuration options for setting them.



#59 - binary data
handle binary data correctly in all databases


#60 - long/lob support
handle long/lob support the same way for all databases


#61 - array datatypes
Support array datatypes in db's that support them.  Oracle calls them collections.


#62 - firebird blob/quad support
Support blobs and quads in firebird.


#63 - timestamp data type
handle timestamp datatypes in all dbs that support them


#64 - mysql enum types
handle enum types with mysql


#65 - replication
Provide front-end replication.  If SQL Relay can talk to two DB's, even different DB's, as long as their tables are compatible, it should be possible to replicate data between them.  Will require two-phase commit and all kinds of cases where the db's get out of sync.


#66 - quotas
Implement data transfer quotas per user, per time-period.


#67 - logging
Currently there is an undocumented method for logging slow queries.

Develop a full-featured logging framework for queries, result sets and performance metrics.


#68 - named transcations
support commit/rollback for named transactions in postgresql, possibly other db's


#69 - SQLBrowseConnect
ODBC connection should use SQLBrowseConnect to look up a connection name in odbc.ini rather than requiring the info that would be in odbc.ini to be in sqlrelay.conf


#70 - Solaris Init Script
Develop an init script for solaris.


#71 - Perl DBI fetchrow_array - dontGetColumnInfo
Call dontGetColumnInfo() when doing Perl DBI fetchrow_array's


#72 - commit/autocommit
Some databases (like postgresql) are in auto-commit mode unless you manually begin a transaction.  SQL Relay calls commit/rollback at the end of a client session, even if the database is in auto-commit mode.  For postgresql at least, this is expensive.  It should only call commit/rollback if the database isn't in auto-commit mode.



#73 - cross db joins
SQLite supports virtual tables implemented via modules.  Create a module that uses the sqlrelay client as a table type. Combine that, the :memory: filename and the query router to achieve cross-db joins.


#74 - xbase support
Either use xbsql or write an sqlite module to support SQL queries against a set of xBase files.


#75 - csv support
Develop an sqlite module that can read csv files and use that to support SQL queries against a collection of csv files.


#76 - db keepalive
Connections should ping database server every so often to make sure it's up, if it's not, relogin.



#77 - failover
Implement front-end failover.

Master/slave and dual-master options.

Should work across dissimilar databases as long as their tables are compatible.


#78 - mysterious connection death
If a connection dies mysteriously, a new one should fire up.  Currently, there's no good way to even detect that one has gone down.



#79 - Ruby-on-rails adapter
Develop a db adapter for rails.


#80 - C# API
Develop a db interface module for C#.


#81 - PHP API's
Pear DB has been superseded by MDB2.  There are also PDO and ADODB interfaces.  Which of these are commonly used?  Develop modules for them.


#82 - Borland Delphi API
Develop an API so SQL Relay can be used with Borland Delphi.


#83 - mysql listener
Develop a listener that implements the mysql client-server protocol, enabling existing apps that use mysql to just be aimed at SQL Relay with no recoding.

Client/Server protocol is documented:
* http://forge.mysql.com/wiki/MySQL_Internals_ClientServer_Protocol

Somebody has already implemented it in perl:
* http://search.cpan.org/~philips/DBIx-MyServer-0.42/lib/DBIx/MyServer.pm


#84 - postgresql listener
Develop a listener that implements the postgresql client-server protocol, enabling existing apps that use postgresql to just be aimed at SQL Relay with no recoding.

Blackray implements a postgresql listener - maybe I can steal code from it.


#85 - firebird listener
Develop a listener that implements the firebird client-server protocol, enabling existing apps that use firebird to just be aimed at SQL Relay with no recoding.


#86 - TDS protocol listener
Develop a listener that implements the TDS client-server protocol, enabling existing apps that use Sybase or MS SQL Server to just be aimed at SQL Relay with no recoding.


#87 - Oracle listener
Develop a listener that implements the oracle client-server protocol, enabling existing apps that use oracle to just be aimed at SQL Relay with no recoding.

This might require reverse-engineering of the protocol and there could be legal issues there.


#88 - DB2 listener
Develop a listener that implements the db2 client-server protocol, enabling existing apps that use db2 to just be aimed at SQL Relay with no recoding.

If the protocol isn't documented, I'll have to reverse-engineer it.  There could be legal issues involved there.


#89 - Informix Support
IBM bought out Informix and there's a free version of the DB available now:

http://www-01.ibm.com/software/data/informix/downloads.html

Develop a connection that can talk to it.


#90 - Google Datastore
Develop a connection daemon that can talk to Google Datastore.


#91 - PHP Pear DB Bind Format Tests
Update PHP tests to test all of the different native bind formats that various db's use.


#92 - DB2 Temp Table Tests
Add tests for DB2 temp tables.


#93 - ODBC Temp Table Tests
Add temp table tests to ODBC tests.


#94 - pythondb tests
Currently the pythondb tests are pretty lame.  Develop full featured pythondb tests, like the perl DBI ones.


#95 - Ruby DBI tests
Currently the ruby dbi tests are pretty lame.  Develop full featured ruby dbi tests, like the perl DBI ones.


#96 - query with length tests
Add tests for send/prepareQuery where the length of the query is specified.


#97 - upper/lower/mixed case column name tests
Add tests for methods that set the column names to upper, lower and mixed case.


#98 - automated db reconnect tests
Put together some tests for each db that bring the db down and verify that SQL Relay will reconnect.


#99 - column flag tests
Add tests for the various column flags.


#100 - getFieldAsXXX tests
Add tests to test the getFieldAsInteger/Double methods.


#101 - getOutputBindAsXXX tests
Add tests to test the getOutputBindAsXXX methods.


#102 - Java getXXXAsByteArray method tests
Add tests for the Java getXXXAsByteArray methods.


#103 - binary data in blob/lob tests
Add tests that insert binary data into blob/lob's and verify that it comes back correctly.


#104 - Perl DBI driver tests
Add tests for the following Perl DBI methods:

* execute_array
* bind_param_array
* selectall_arrayref with attr/binds
* selectall_hashref with attr/binds
* selectcol_arrayref with attr/binds
* selectrow_array with attr/binds
* selectrow_arrayref with attr/binds
* selectrow_hashref with attr/binds
* prepare_cached
* fetchall_arrayref with slice
* quote
* err
* errstr
* state
* begin_work
* available_drivers
* data_sources


#105 - Zope API Bugs
The Zope API needs to be modernized, it has the following problems:

* doesn't handle sybase money types right
* !ImageFile needs to be App.!ImageFile in zope 2.11 and up
* meta_types, _ac_permissions_ - and methods attributes are long deprecated
* installing under lib/python/Products in zope 2 doesn't work
* zope 3 doesn't have lib/python/Products



#106 - PHP Pear DB Binds
The PHP Pear DB driver doesn't handle ? chars properly inside double quotes.  I think it probably also doesn't handle escaped quotes properly either.


#107 - DB2 LANG issues
There are cases with DB2 where data in a DB that's not using UTF-8 may be returned converted to UTF-8.  How do we get the data out in the same encoding that it's in the DB in?

http://www.ibm.com/developerworks/data/library/techarticle/dm-0506chong/index.html



#108 - query timeout hang
Allowing query timeout appears to hang the sqlrelay server.


#110 - ODBC API version detection
Just because sqlrelay is compiled against unixodbc which supports the odbc 3.0 api, individual drivers may not support the 3.0 api, so sqlrelay needs to detect this or it needs to at least be configurable use SQLGetInfo with SQL_ODBC_API_CONFORMANCE, can return:
* SQL_OAC_NONE
* SQL_OAC_LEVEL1
* SQL_OAC_LEVEL2


#111 - query router "do somethings"
Address the "FIXME: do somethings" in various places in the query router.  Some of these are not easy fixes.


#112 - SID
Get SID working and documented or remove it.

SID may not be necessary, binds and escaping can prevent SQL injection, verify that they are sufficient in SQL Relay and put docs in the FAQ.
See http://en.wikipedia.org/wiki/SQL_injection

SID how to:

* create db
* create user
* mysql -usiddb -psiddb siddb < siddb
* set up sqlrelay instance to talk to it
* set up another instance to use siddb instance for sid
* populate siddb
* sidparameters:
 * sparam = one of...
  * INGRESS - perform ingress filtering
  * EGRESS - perform egress filtering
  * LISTEN - ???
  * VERIFICATION - don't send queries to db
  * PREVENTION - send queries to db if ok
 * svalue=1/0
* sidingressblist - ingress blacklist
 * sql_state - queries to reject
* sidingresswlist - ingress whitelist
 * sql_state - queries to accept, overrides blacklist
* sidingressldb - ingress learning database
 * parsed_sql - ???
* sidegressblist - egress blacklist
 * sql_state - "parsed results" to reject
* sidegresswlist - egress whitelist
 * sql_state - "parsed results" to accept overrides blacklist
* sidegressldb - egress learning database
 * parsed_sql - ???
* what are "parsed results" - something to do with column names...
 * sidlog - every query is logged here with a message about it


#113 - client disconnect issue
If a client connects and the forked listener ends up waiting for a connection and the client disconnects, the forked listener has no way of knowing that the client has disconnected and can't bail.


#114 - semaphore - ENOSPC issue
semop's can return ENOSPC if the undo list is full which is unhandled and causes deadlocks in the sqlr-listeners.  If we get an ENOSPC, then we need to send the client an error and the sqlr-listener needs to exit.


#115 - redistribute connections
Need to find a way to re-distribute connections.  If 2 db's go down and 2nd comes back up first, all log into 2nd db and never log out and back into first connection daemons could just re-log in on a random interval


#116 - TTL being ignored
If scaler fires off connections, one doesn't time out.  This is actually more generic - connections which have announced themselves as available to the listener disable their ttl alarm so they won't die off after being registered.



#117 - scaler reaper - SIGCHLD
scaler reaper should fire off from SIGCHLD and not depend on another client connection.

There are various issues with this.

* The signal handler would need to be a static method but access member variables of the instance.

* Renat suggests: The problem is with signal handler rules. It could set only one type of static variable -  sig_atomic_t. So I think it is possible to count reaped children in signal handler in variable n_reaped and then (since semset->wait(6) would exit and set EINTR) in the main code block SIGCHLD, change shm and set n_reaped to 0 . A little bit tricky, but should work.


#296 - multiple result sets
Support queries which return multiple result sets.  A few db's support this.  

Some allow you to run multiple queries, separated by ;'s.

In others, a stored procedure might return multiple cursors (http://publib.boulder.ibm.com/infocenter/iseries/v5r4/index.jsp?topic=%2Fsqlp%2Frbafyresultsete2.htm)


